% !TEX root = laws.tex
\raggedbottom
\subsection{Related Work}

Verification and testing of software systems is an integral part of a software development lifecycle. Immediately after the implementation of the software, and before its deployment, it has to be verified and tested extensively enough to ensure that all the functional requirements have been properly met. A lot of methods have been developed over the course of time for verification and testing of software. Formal verification, for example, is a popular method of program verification~(though testing still remains more prevalent). It is used to validate the correctness of a software module by modeling its behaviour based on a set of formal methods, which are mathematical models specifying the intended functional behaviour. Though there are a lot of formal methods used for this, and are selected based on the functional outlook of the software program, the most common methods are the ones based on finite state machines, Petri Nets, process algebra and timed automata. Prior to formal verification, a mathematical model employing a formal method is decided upon which is then followed by a specification phase where the behaviour of the system is modeled. Finally the actual program is verified against this behaviour specification which is called the verification phase. In the late 90's, some optimisations were proposed to the otherwise conventional and inefficient exhaustive search methods [?] \mnote{add reference}%[http://spinroot.com/spin/Doc/forte94a.pdf].%

Since a software program is developed at module or class level and is integrated with other modules or classes along the development cycle, testing is done at unit level, integration level and system level\bruno{What about end-to-end tests, performance tests, ...?}, before the software is deployed. Unit tests target individual modules, methods or classes and have a small coverage compared to integration tests which aim towards checking the behaviour of modules when combined together. The two main approaches to unit testing are black box testing and white box testing. The former one focuses on designing test instances without looking inside the code or design, and in other words black box testing only focuses on the functionality, while the latter approach is more inclined towards testing code coverage i.e. writing test instances which employ the different paths inside the code. Though initially white box testing was considered as a method suitable for unit testing alone, recently it has emerged as a popular method for integration testing as well. Integration testing is usually done by one or a combination of big-bang approach, top-down approach, bottom-up approach and the sandwich approach. Following this, the final full scale testing that a software undergoes is called the system testing which includes a lot of tests including security test, compatibility test, exception handling, scalability tests and some performance tests. 

Opposed to the conventional unit testing methods which are closed i.e. they do not take any input parameters, Parameterized unit tests [?] \mnote{add main paper here} %(a reference paper - https://pdfs.semanticscholar.org/1f24/4a89f55a461a4f9fa9843710209b1d4117a2.pdf)
are generalized tests which have an encapsulated collection of test methods whose invocation and behaviour is controlled by a set of input parameters giving more flexibility and automation to unit testing as a whole. 

In this manuscript, we focus on a different method of program testing and verification, called property testing. A property testing algorithm is concerned with making approximate decisions as to whether an entity, which is modelled mathematically as a function, satisfies a property globally or is far from having the property, using only a small number of queries (compared to the function's domain).
%Some papers to use for references particular to property testing - http://www.wisdom.weizmann.ac.il/~oded/test.html.%
