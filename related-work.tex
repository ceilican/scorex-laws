% !TEX root = laws.tex


\section{Related Work}

Verification and testing of software systems is an integral part of a software development lifecycle. Immediately after the implementation of the software, and before it's deployment, it has to be satisfactorily verified and tested to ensure that all the functional requirements have been properly met. A lot of methods have been developed over the course of time for verification and testing of softwares. Formal verification is one of the most popular methods of program verification. Formal verification is used to validate the correctness of a software module by modelling it's behaviour based on a set of formal methods, which are mathematical models specifying the intended functional behaviour. Though there are a lot of formal methods used for formal verification, and are selected based on the functional outlook of the software program, the most common methods are the ones based on finite state machines, Petri Nets, process algebra and timed automata. Prior to formal verification, a mathematical model employing a formal method is decided upon which is then followed by a specification phase where the behaviour of the system is modelled. Finally the actual program is verified against this behaviour specification which is called the verification phase. In the late 90's, some optimisations were proposed to the otherwise conventional and inefficient exhaustive search methods [http://spinroot.com/spin/Doc/forte94a.pdf]. Properties like safety and liveness are often modelled and verified using finite state machines. For example in order to check the security mechanism inside a software, states can be divided into secure and non-secure states and then an analysis around the set of reachable states can prove the software's security.

Since a software program is developed at module or class level and is integrated with other modules or classes along the development cycle, testing is done at both, unit level as well as integration level, before the software is deployed. Unit tests target individual modules, methods or classes and have a small coverage compared to integration tests which aim towards checking the behaviour of modules when combined together. The two main approaches to unit testing are black box testing and white box testing. The former one focuses on designing test instances without looking inside the code or design, and in other words black box testing only focuses on the functionality, while the latter approach is more inclined towards testing code coverage i.e. writing test instances which employ the different paths inside the code. Though initially white box testing was considered as a method suitable for unit testing alone, recently it has emerged as a popular method for integration testing as well. Integration testing is usually done by one or a combination of big-bang approach, top-down approach, bottom-up approach and sandwich approach. Big-bang is the most naive approach where all the modules are combined at once and then tested, followed by top-down approach, where firstly the main routine is tested and then other subroutines are added with each level. In bottom-up approach the most independent subroutines are first tested and then they are integrated gradually with each level, which is followed by the sandwich approach which is a combination of top-down and bottom-up approach. The final full scale testing that a software undergoes is called the system testing which includes a lot of tests including security test, compatibility test, exception handling, scalability tests and some performance tests. \\

Opposed to the conventional unit testing methods which are closed i.e. they do not take any input parameters, Parameterized unit tests (add the main paper here) %(a reference paper - https://pdfs.semanticscholar.org/1f24/4a89f55a461a4f9fa9843710209b1d4117a2.pdf)
are generalised tests which have an encapsulated collection of test methods whose invocation and behaviour is controlled by a set of input parameters giving more flexibility and automation to unit testing as a whole. \\

In this manuscript, we focus on a different method of program testing and verification, called property testing. A property testing algorithm is concerned with making approximate decisions as to whether an entity, which is modelled mathematically as a function, satisfies a property globally or is far from having the property, using only a small number of queries (compared to the function's domain).\\
%Some papers to use for references particular to property testing - http://www.wisdom.weizmann.ac.il/~oded/test.html.%