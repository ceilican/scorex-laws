% !TEX root = laws.tex


\section{Related Work}

Verification and testing of software systems is an integral part of a software development lifecycle. Immediately after the implementation of the software, and before it's deployment, it has to be satisfactorily verified and tested to ensure that all the functional requirements have been properly met. On an average, it has been seen that 95-99\% of the total bugs in a software can be tackled if a proper testing methodology is utilised. Formal verification is one of the most popular methods of program verification. Formal verification is used to validate the correctness of a software module by modelling it's behaviour based on a set of formal methods, which are mathematical models specifying the intended functional behaviour. Though there are a lot of formal methods used for formal verification, and are selected based on the functional outlook of the software program, but the most common methods are the ones based on finite state machines, Petri Nets, process algebra and timed automata. Prior to formal verification, a mathematical model employing a formal method is decided upon which is then followed by a specification phase where the behaviour of the system is modelled, and finally the actual program is verified against this behaviour specification which is called the verification phase. In the late 90's, some optimisations were proposed to the otherwise conventional and inefficient exhaustive search methods [http://spinroot.com/spin/Doc/forte94a.pdf]. Write something about these optimizations and find some more past work.\\

Since a software program is developed at module or class level and is integrated with other modules or classes along the development cycle, testing is done at both, unit level as well as integration level, before the software is deployed. Unit tests target individual modules, methods or classes and have a small coverage compared to integration tests which aim towards checking the behaviour of modules when combined together. The two main approaches to unit testing are black box testing and white box testing, where the former one focuses on designing test instances without looking inside the code or design, in other words black box testing only focuses on the functionality, and the latter approach is more inclined towards testing code coverage i.e. writing test instances which employ the different paths inside the code. Though initially white box testing was considered as a method suitable for unit testing alone, recently it has emerged as a popular method for integration testing as well. Integration testing is usually done by one or a combination of big-bang approach, which is the most naive approach where all the modules are combined at once and then tested, top-down approach, where firstly the main routine is tested and then other subroutines are added with each level, bottom-up approach, where the most independent subroutines are first tested and then they are integrated gradually with each level and sandwich approach which is a combination of top-down and bottom-up approach. The final testing that a software undergoes is called the system testing which includes a lot of tests including security test, compatibility test, exception handling, scalability tests and some performance tests. \\

Opposed to the conventional unit testing methods which are closed i.e. they do not take any input parameters, Parameterized unit tests (add the main paper here) %(a reference paper - https://pdfs.semanticscholar.org/1f24/4a89f55a461a4f9fa9843710209b1d4117a2.pdf)
are generalized tests which have an encapsulated collection of test methods whose invocation and behaviour is controlled by a set of input parameters giving more flexibility and automation to unit testing as a whole. \\

Add a small paragraph about property testing here.