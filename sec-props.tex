% !TEX root = laws.tex

\section{Blockchain properties}
\label{sec:props}

In this section we provide our approach to generalized testing of abstract blockchain-like system design. For extensive testing we are  testing history, minimal state and memory pool separately, and also node view holder which updates the quadruple {\em <history, minimal state, vault, memory pool>} in an atomic way.

History is a log of {\em persistent modifiers}. A modifier is persistent in the sense that it has an unique identifier, and it is always possible to check that the modifier was ever appended to the history~(knowing its identifier). There is no any requirements on a modifier structure, besides the requirement to have an unique identifier, and also to have at least one parent~(referenced by its identifier). If modifier could be applied to a history, we call it {\em syntactically} valid. In addition so syntax, there is some stateful semantics, and minimal state is taking care of it. That is, all nodes are agree on some pre-historical state $S_0$ and then by applying the same sequence of persistent modifiers $m_1, \ldots, m_k$ in a deterministic way, all the nodes are getting the same state $S_k = apply(\ldots apply(apply(S_0, m_1), m_2), m_k)$ if all the $m_1, \ldots, m_k$ are {\em semantically} valid; otherwise a node is getting an error on the first application on a semantically invalid persistent modifier. From our mere abstract point of view, the goal of obtaining the state $S_k$ is to check whether a new modifier $m_{k+1}$ will be correct or not. Thus the minimal state has very few mandatory functions to implement, such as $apply(\dot)$. For a user running a node, the goal to run it is usually to get valuable user-specific information. For that, the vault component is used which has only function to update itself by scanning whether a persistent modifier or a {\em transaction}. A transaction, unlike a persistent modifier, has no mandatory reference to its parents); also we consider that a transaction is not to be applied to the history and minimal state. To store transactions~(temporarily, before them being included into persistent modifiers), the memory pool is needed.      


\subsection{Generators}

In our test suites we use generators for the objects that are used to check the laws of a blockchain. The developer of a concrete system needs to implement these generators. We provide interfaces for generators of the following types of objects:

\begin{itemize}
	\item{Syntactically valid (respectively, invalid) modifier, which is valid (respectively, invalid) based on the node's local view of history.}
	\item{Semantically\bruno{It seems the notion of semantic validity has not been defined in this paper yet.} valid (respectively, invalid) modifier, which is valid (respectively, invalid), based on the node's local view of minimal state.}
	\item{Totally, so both semantically and syntactically, valid modifier. Respectively, a sequence of totally valid modifiers}
	\item{Transaction}
\end{itemize}

For example, in our TwinsCoin implementation, we provide a concrete implementation for these interfaces. To generate syntactically valid modifiers, we generate a PoW block if a previous pair of {\em<PoW block, PoS block>} is complete, otherwise we generate a new PoS block. It can be noted that, in TwinsCoin, transactions are only recorded in PoS blocks. A minimal state in our TwinsCoin implementation deterministically determines the validity of an arbitrary transaction. To generate semantically valid modifiers we generate a PoS block including transactions based on unspent transaction outputs, or unspent boxes. A totally valid modifier generator has a matching PoS block among a syntactically valid and a semantically valid modifier. A generated transaction takes as input unused boxes and returns as output a set of new boxes.

\subsection{Forking}


\knote{forking}
