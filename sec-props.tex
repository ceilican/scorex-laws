% !TEX root = laws.tex

\section{Blockchain properties}
\label{sec:props}

In this section we provide our approach to generalized testing of an abstract blockchain-like system design. For extensive testing, we test history, minimal state and memory pool separately, and also node view holder which updates the quadruple {\em <history, minimal state, vault, memory pool>} in an atomic way.

History is a log of {\em persistent modifiers}. A modifier is persistent in the sense that it has a unique identifier, and it is always possible to check if the modifier was ever appended to the history~(by presenting its identifier). There are no requirements on a modifier structure, besides the requirements to have a unique identifier and at least one parent~(referenced by its identifier). If a modifier could be appended to a history, we call it {\em syntactically} valid. In addition to syntax of the blockchain, there are some stateful semantics, and minimal state takes care of them. That is, all nodes agree on some pre-historical state $S_0$ and then by applying the same sequence of persistent modifiers $m_1, \ldots, m_k$ in a deterministic way, all the nodes get the same state $S_k = apply(\ldots apply(apply(S_0, m_1), m_2), m_k)$ if all the $m_1, \ldots, m_k$ are {\em semantically} valid; otherwise a node gets an error on the first application of a semantically invalid persistent modifier. From our mere abstract point of view, the goal of obtaining the state $S_k$ is to check whether a new modifier $m_{k+1}$ will be correct or not. Thus the minimal state has very few mandatory functions to implement, such as $apply(\dot)$. For a user running a node, the goal to run it is usually to get valuable user-specific information. For that, the vault component is used which has the only function to update itself by scanning a persistent modifier or a {\em transaction}. A transaction, unlike a persistent modifier, has no mandatory reference to its parents; also we consider that a transaction is not to be applied to the history and minimal state. To store transactions~(temporarily, before them being included into persistent modifiers), the memory pool is needed.      


\subsection{Generators}

In our test suites we use generators for the objects that are used to check the laws of a blockchain. The developer of a concrete system needs to implement these generators. We provide interfaces for generators of the following types of objects:

\begin{itemize}
	\item{Syntactically valid (respectively, invalid) modifier, which is valid (respectively, invalid) based on the node's local view of history.}
	\item{Semantically valid (respectively, invalid) modifier, which is valid (respectively, invalid), based on the node's local view of minimal state.}
	\item{Totally, so both semantically and syntactically, valid modifier. Respectively, a sequence of totally valid modifiers}
	\item{Transaction}
\end{itemize}

For example, in our TwinsCoin implementation, we provide concrete implementations for these generators. To generate syntactically valid modifiers, we generate a Proof-of-Work (PoW) block if a previous pair of {\em<PoW block, PoS block>} is complete, otherwise we generate a new Proof-of-Stake (PoS) block. It can be noted that, in TwinsCoin, transactions are only recorded in PoS blocks. A minimal state in our TwinsCoin implementation, similarly to Bitcoin, is defined as a set of unspent transaction outputs, and deterministically determines the validity of an arbitrary transaction, or a sequence of transactions. To generate semantically valid modifiers, we generate a PoS block including transactions based on unspent transaction outputs. A totally valid modifier generator has a matching PoS block among a syntactically valid and a semantically valid modifier. Generated transactions take as input unspent outputs and return as output a set of new randomly generated outputs.

\subsection{Implicit properties}

We implicitly define some properties. For example, the existence of a generator for a totally valid modifier for any given correct history and valid minimal state assumes that it is always possible to make a progress. \knote{continue, what else properties do we implicitly assume?}

\subsection{Simple properties}

We can define a lot of trivial properties. For example, if a modifier has been appended to a history, it is always possible to get it at some later point of time, for any implementation of the history interface and any syntactically valid modifier. In opposite, if modifier is syntactically invalid, it should be not possible to get it by requesting from history. 

\subsection{Forking}


\knote{forking}
