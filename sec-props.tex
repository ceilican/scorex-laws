% !TEX root = laws.tex

\section{Blockchain properties}

In this section we provide our approach to generalized testing of abstract blockchain-like system design. For extensive testing we are  testing history, minimal state and memory pool separately, and also node view holder which updates the quadruple {\em <history, minimal state, vault, memory pool>} in an atomic way.


\subsection{Generators}

In our test suites we are using generators for objects we are using to check laws of a blockchain. A developer of a concrete system needs to implement these generators. We provide interfaces for generators of following types of objects:

\begin{itemize}
	\item{Syntactically valid, respectively, invalid modifier, which is valid, respectively invalid, based on a node's local view of history.}
	\item{Semantically valid, respectively, invalid modifier, which is valid, respectively invalid, based on a node's local view of minimal state.}
	\item{Totally, so both semantically and syntactically, valid modifier. Respectively, a sequence of totally valid modifiers}
	\item{Transaction}
\end{itemize}

For example, in our TwinsCoin implementation, we provide a concrete implementation to these interfaces. To generate syntactically valid modifiers, we generate a PoW block if a previous pair of {\em<PoW block, PoS block>} is complete, otherwise we generate a new PoS block. It can be noted that, in TwinsCoin, transactions are only added to PoS blocks. A minimal state in this implementation deterministically determines the validity of an arbitrary transaction. To generate semantically valid modifiers we generate a PoS block based on transaction outputs, or boxes. A totally valid modifier generator has a matching PoS block among a syntactically valid and a semantically valid modifier. A generated transaction takes as input unused boxes and returns as output a set of new boxes.

\subsection{Forking}


\knote{forking}
