% !TEX root = laws.tex

\section{Blockchain properties}
\label{sec:props}

In this section we discuss our approach to generalized testing of an abstract blockchain-like system. For extensive testing, we test history, minimal state and memory pool separately, and also do thorough checks for node view holder properties.
	
In total, we have implemented 59 property tests. They are using random object generators described in Section~\ref{sec:generators}. Most of the tests are relatively simple, some examples are provided in Section~\ref{sec:simple-props}. Other tests could check complex functionalities where several components are involved. As a particular example, we provide details on testing fork processing in Section~\ref{sec:forking}.

\subsection{Generators}
\label{sec:generators}

In our test suites we use generators for objects which are used to check the laws of a blockchain. A developer of a concrete system needs to implement these generators. We provide interfaces for generators of the following types of objects:

\begin{itemize}
	\item{a syntactically valid (respectively, invalid) modifier, which is valid (respectively, invalid) based on the node's local view of history.}
	\item{a semantically valid (respectively, invalid) modifier, which is valid (respectively, invalid), based on the node's local view of minimal state.}
	\item{a totally, so both semantically and syntactically, valid modifier. Respectively, a sequence of totally valid modifiers}
	\item{a transaction}
\end{itemize}

As an example, for the TwinsCoin we provide concrete implementations for these generators. To generate syntactically valid modifiers, we generate a Proof-of-Work (PoW) block if a previous pair of {\em<PoW block, PoS block>} is complete, otherwise we generate a new Proof-of-Stake (PoS) block. It can be noted that, in TwinsCoin, transactions are only recorded in PoS blocks. A minimal state in our TwinsCoin implementation, similarly to Bitcoin, is defined as a set of current unspent transaction outputs. To generate semantically valid modifiers, we generate a PoS block including transactions based on unspent transaction outputs. A totally valid modifier generator has a matching PoS block among a syntactically valid and a semantically valid modifier. %Generated transactions take as input unspent outputs and return as output a set of new randomly generated outputs.

We implicitly define some properties. In particular, the existence of a generator for a totally valid modifier for any given correct history and valid minimal state assumes that it is always possible to make a progress in constructing a blockchain.

\subsection{Simple properties}
\label{sec:simple-props}

We provide some examples of simple properties we are checking here. If a modifier has been appended to a history, it is always possible to get it at some later point of time, for any implementation of the history interface and any syntactically valid modifier. In opposite, if modifier is syntactically invalid, it should be not possible to get it by requesting from history. Similarly, if a persistent modifier is semantically valid against a minimal state, the former could be applied to the latter. Even more, after application we can, roll the application back and successfully apply the persistent modifier again.  

For a {\em node view synchronizer} component, which acts as a proxy layer between the node view holder and networking protocol, we checks, in particular, that if a transaction or a persistent modifier is coming in from a simulated ``peer'', the node view holder is getting it within a reasonable timeout. Similarly, if a transaction or a persistent modifier is coming from simulated local side, the synchronizer should send it to a network layer within a timeout.

\subsection{Forking}
\label{sec:forking}

Processing forks could be a complicated issue, making testing of this functionality important. We proceed by describing the way in which forking is implemented in Scorex. When a persistent modifier is appended to the history, it returns~(if the modifier is syntactically valid) {\em progress info} structure which contains a sequence of persistent modifiers to apply as well as a possible identifier of a modifier to rollback~(for the minimal state, vault, memory pool) before the application of the sequence. For efficiency reasons, the minimal state is usually limited in maximal depth for a rollback, so the rollback could fail~(this situation is probably unresolvable in a satisfactory way without a human intervention). 

We have implemented forking tests for the node view holder. The tests are checking that shorter sequence of totally valid persistent modifiers is not resulting in a fork, a longer sequence leads to a fork. A separate test is trying to apply a fork longer than the maximal rollback depth and checks whether the node view holder is emitting a needed alert.
