% !TEX root = laws.tex

\section{Blockchain properties}
\label{sec:props}

In this section we provide our approach to generalized testing of abstract blockchain-like system design. For extensive testing we are  testing history, minimal state and memory pool separately, and also node view holder which updates the quadruple {\em <history, minimal state, vault, memory pool>} in an atomic way.

History is a log of persistent modifiers. A modifier is persistent in the sense that it has an unique identifier, and it is always possible to check that the modifier was ever appended to the history. There is no any requirements on a modifier structure, besides the requirement to have an unique identifier, and also to have at least one parent~(referenced by its identifier). 




\subsection{Generators}

In our test suites we use generators for the objects that are used to check the laws of a blockchain. The developer of a concrete system needs to implement these generators. We provide interfaces for generators of the following types of objects:

\begin{itemize}
	\item{Syntactically valid (respectively, invalid) modifier, which is valid (respectively, invalid) based on the node's local view of history.}
	\item{Semantically\bruno{It seems the notion of semantic validity has not been defined in this paper yet.} valid (respectively, invalid) modifier, which is valid (respectively, invalid), based on the node's local view of minimal state.}
	\item{Totally, so both semantically and syntactically, valid modifier. Respectively, a sequence of totally valid modifiers}
	\item{Transaction}
\end{itemize}

For example, in our TwinsCoin implementation, we provide a concrete implementation for these interfaces. To generate syntactically valid modifiers, we generate a PoW block if a previous pair of {\em<PoW block, PoS block>} is complete, otherwise we generate a new PoS block. It can be noted that, in TwinsCoin, transactions are only recorded in PoS blocks. A minimal state in our TwinsCoin implementation deterministically determines the validity of an arbitrary transaction. To generate semantically valid modifiers we generate a PoS block including transactions based on unspent transaction outputs, or unspent boxes. A totally valid modifier generator has a matching PoS block among a syntactically valid and a semantically valid modifier. A generated transaction takes as input unused boxes and returns as output a set of new boxes.

\subsection{Forking}


\knote{forking}
