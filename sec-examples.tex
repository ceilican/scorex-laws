% !TEX root = laws.tex

\section{Examples of properties tests}
\label{sec:examples}

To explain our approach to the testing of a client in details, in this section we provide some examples of property tests which are valid for most of blockchain-based systems. We have grouped the tests based on their similarity.\\

\begin{enumerate}[\IEEEsetlabelwidth{Z}]

\item \textit{Memory pool Tests}.\\
Memory Pool (or just mempool in the Bitcoin jargon) is used to store unconfirmed transactions which are to be included into persistent modifiers. The following tests are used to check some general properties of a memory pool which every blockchain client should pass.

\begin{itemize}[\IEEEsetlabelwidth{Z}]

\item \textit{A memory pool should be able to store enough transactions.}\\
In our TwinsCoin implementation, we are testing that the mempool which is empty before the test should be able to store a number of transactions up to a maximum specified in settings.\\

\item \textit{Filtering of valid and invalid transactions from a mempool should be fast}.\\
We are checking that an implementation of mempool is able to filter out an invalid transaction reasonably fast. As processing time is platform-dependent, the test during its instantiation is measuring time to calculate 500,000 blocks of SHA-256 hash. Time to filter out the transaction should be no more than that. \\

\item \textit{A transaction successfully added to memory pool should be available by a transaction identifier.}\\
The purpose of this test is to ensure that once a transaction is added to the memory pool, it indeed is available by a transaction identifier. The test simply adds the transaction to the memory pool and then query the transaction by its identifier. The initial transaction is the only correct result of the compound operation. \\
\end{itemize}
\item \textit{History Tests.}\\

A history is an abstract data structure which records all the persistent modifiers ever appended to it. We recall that the blockchain structure in the Bitcoin protocol is the example of a history implementation. Since history is an integral part of a node view, it is important to check if an implementation of history acts correctly. A consensus protocol aims at establishing common history for all the nodes on the network.

A persistent modifier is the main building block of a history and is used to update the history and a minimal state. As soon as a valid modifier gets appended to history, a node's local view changes in the sense that the history is updated, possibly along with the minimal state.

\begin{itemize}[\IEEEsetlabelwidth{Z}]
\item \textit{A syntactically valid persistent modifier should be successfully applied to history and available by its identifier after that}.\\
A syntactically valid persistent modifier, once applied to the history, should be available by its unique identifier. The importance of this test comes from the fact that it is of utmost importance for the client implementation to tell the difference between the modifiers that have been appended to the history from those that have not been added. For this purpose, the unique identifier of the modifier can be used to query the history to know whether the modifier has been added to the history of not.\\

\item \textit{A syntactically invalid modifier should not be able to be added to history.}\\
A syntactically invalid modifier should not be added to history and hence, should not be available by id.\\

\item \textit{Application of a syntactically invalid modifier (inconsistent with the previous ones) should be unsuccessful}.\\
When the unique identifier of an invalid modifier is queried from history, it should always return empty result which shows that the invalid modifier has not been added to the history.\\

\item \textit{Once a syntactically invalid modifier is appended to history, it should not be available in history by its identifier.}\\
A syntactically invalid modifier is one which is inconsistent with the present view of history. Only syntactically valid modifier is eligible to be applied to history. To filter out invalid modifiers before adding them to history, we propose this test. We generate a random invalid modifier and attempt to add it to history. Since it is invalid, history should not add it and hence, it should not be available by identifier when queried from history. Some examples of generating invalid modifiers are - generate false nonce which doesn't satisfy the puzzle, generate false signatures which validate to false when checked with the public key of the signer, etc.\\

\item \textit{Once a syntactically valid modifier is appended to history, the history should contain it.}\\
This test ensures that all the valid modifiers are correctly appended to the history meaning that they are indeed capable of changing the node's view. Since the history appends valid modifiers only, only should a valid modifier by available by identifier when queried from history.\\

\item \textit{History should be able to report if a modifier is semantically valid after successfully appending it to history.}\\
This purpose of this test if to check the consistency in the working of minimal state and the history. Whenever a node's view is updated, both the history and the state should be updated in harmony and consistently with one another. Since a semantically valid modifier in one which is valid based on a node's view of minimal state, history should be able to correctly report the validity of semantically valid modifier after appending it. This also implies that the history should always report the semantic validity of an appended modifier as "valid" since only totally valid modifiers should be able to append to history. On a side-note, this test also checks that history indeed is checking that only totally valid modifiers, and not just syntactically valid ones (the modifiers valid based on history) are appended to history.\\
\end{itemize}
\item \textit{Minimal State Tests.}\\
In case of an unwanted event, a rollback has to be performed which essentially rolls the system back to a previous "safe" (changes the current system state to a state in the past which has been verified and is seemingly correct) state and hence recovers the system from the unwanted state. A very common example where a rollback might be necessary is when a system has to recover from a fork issue.

\begin{itemize}[\IEEEsetlabelwidth{Z}]

\item \textit{Application and rollback should lead to the same minimal state.}\\
In this test, a semantically persistent modifier $m$ is generated and applied to a current state $S$. Due to this application of the modifier, a new minimal state $S'$ is to be obtained from $S$. After the modifier is applied successfully to the history, a rollback is performed to take the system back to state $S$ from the current state $S'$. The test now checks that the state to which the system comes after the rollback is indeed the state $S$ by checking an identifier of the new state after rollback is the same as the identifier of the original state.\\

We now use this test to explain how we generate a semantically valid modifier for the Twinscoin client. Before proceeding, we define the structure of a transaction $t$. A simple transaction is usually represented as the map $T : UTXO \to UTXO$, where $UTXO$ is the set of all the unspent transaction outputs or \textit{boxes}. A box can be considered as a tuple ($pubkey, amount$) where $pubkey$ is the public key of the account of the node to which this box belongs to and $amount$ refers to the monetary (in case of cryptocurrencies) amount which this box holds in the name of the $pubkey$ in the first half of the tuple. A transaction uses some ($\geq 0$, 0 in the case of the rewarding transaction which is present at the end of each block and which rewards the miner) unspent boxes and generates new boxes with a constraint that sum of the amount of all the boxes used in the transaction is equal to the sum of amount of the boxes output by the transaction except the rewarding transaction for which this constraint doesn't apply. Once the new boxes have been added to the UTXO set, the old boxes which were input to the transaction are removed from the UTXO set to prevent double spending. This addition and removal of boxes from $UTXO$ set has to be done atomically in order to avoid inconsistencies in the system. Suppose a node $A$ wants to send $x$ amount to a node $B$, then the transaction for this purpose will use some boxes with $A$s public key on them which sum up to an amount $y \geq x$ and output the boxes $b_1$ and $b_2$ such that $b_1 = (B, x)$ which has $B$s public key and an amount $x$ whereas $b_2 = (A, y-x)$ will have $A$s public key and an amount of $y-x$, if $y>x$. Now $B$ has received a new box $b_1$ which belongs to him and this box now sits inside the set $UTXO$ until the point when $B$ uses this box an one of the inputs to a future transaction. Readers should note that for more readability we will represent a transaction $T$ by a tuple ([$in_1, in_2, ...$], [$o_1, o_2, ...$]) where $in_i$ denotes input boxes to the transaction and $o_i$ denotes the output boxes of the transaction.\\
Along with checking that the $id$s are same, it also checks that the components of the new state are also rolled back and not just the $id$ number got rolled back. For this, we generate the modifier $m$ in the following way:
\begin{itemize}
\item Generate a pair of transactions ($t_1, t_2$) where $t_1 = ([b_{1}], [b_{2}])$ and $t_2 = ([b_{2}], [b_{3}])$. This notation means that the first transaction $t_1$ uses a box $b_1$ as its input and then outputs a box $b_2$ which is then used by the second transaction as its input. In the above setting, we select the first input box $b_1$ randomly from the set $UTXO$ and finally output the box $b_3$ from $t_2$ which also just generates a random box ($b_3$). The generated transaction pair has to be valid in the sense that it should only use valid unspent boxes from $UTXO$ and satisfy the constraint that the sum of amounts of all the input boxes should be equal to the sum of amounts of the output boxes. The main caveat here is that the second transaction of the pair should use the output box of the transaction of the first transaction of the pair.
\item Now we generate a pair of modifiers ($m_1, m_2$) and include both of these transactions from the pair above in the respective modifiers.
\end{itemize}

Once the custom modifiers are generated, $m_1$ (first half of the pair) is appended to the history and the system moves from state $s_1$ to the state $s_2$. As mentioned before, the transaction $t_1$ from the pair uses a random box $b_1$ from the $UTXO$ of state $s_1$ and when the system moves to the state $s_2$, the $UTXO$ gets added with the box $b_2$ and $b_1$ is removed from the set. Once the state change happens, we append $m_2$ (second half of the modifier pair) to history progressing the system to state $s_3$. Since $m_2$ contains the transaction $t_2$ which takes as input $b_2$, when the system moves to $s_3$, $b_2$ is removed from $UTXO$ and $b_3$ is added.\\

It will now become clear why we generated pairs of transactions and modifiers in the way defined above. Finally, we perform a rollback from state $s_3$ to $s_2$ which should mean that once the rollback is successful, the box $b_2$ should come back to the set $UTXO$ and should be available by $id$ whereas the box $b_3$ should now not be present inside the $UTXO$ set anymore. Both of these checks tell us that the rollback was performed correctly and the system indeed came back to the previous state with all its components. The reason that we generated the pairs of transactions above is because it helps us in easily checking by $id$ if $b_2$ has returned to the $UTXO$ set since we generated $b_2$ ourselves and know its $id$ already. This makes testing easy and transparent. We would like to mention that this test could also be performed without creating the pairs that we have mentioned above.\\

\item \textit{Application of a valid modifier after a rollback should be successful.}\\
As the previous test aimed at checking that the components of a state are recovered after a rollback happens, it would be quite wrong to think that it should be the only test that is necessary to check if the rollback system performs as expected. It is also equally important that after rollback the system performs normally, as it would perform if the rollback would have never happened. To check this property to certain degree, we propose this test. In this test, we check that after a rollback has happened the system becomes stable again and any new valid modifier which is now added to the history is actually recorded and hence should be available if queried from history. This test ensures that after recovering from a rollback the system performs normally and can resume its functioning without any issues. It hence ensures that a continuity is maintained after a rollback.\\
\end{itemize}
\item \textit{Common Component Tests.}
\begin{itemize}[\IEEEsetlabelwidth{Z}]

\item \textit{Application of the same modifier twice should be unsuccessful.}\\
This test checks that a persistent modifier should not be added more than once. Since if a modifier is added twice, all the transaction inside the modifier will be double spent, so an implementation of a blockchain system should prevent addition of a modifier twice. In this test, we generate a modifier, then append it to history once and on the second application of the modifier again to history, the history should return an unsuccessful addition.\\
\end{itemize}

\item \textit{Node View Holder Tests.}\\
As was mentioned in Section~\ref{sec:scorex}, node view holder is the central component of a blockchain node which is responsible for atomically updating the quadruple \textit{<history, minimal state, vault, memory pool>}. The update could be triggered by whether a persistent modifier of a transaction coming in. 


\begin{itemize}[\IEEEsetlabelwidth{Z}]

\item \textit{Totally valid modifier should successfully update the minimal state and the history.}\\
We recall that a totally valid modifier is a persistent modifier which is valid for both the history and the minimal state, so it is applicable to both of them. In this test we are sending a random totally valid persistent modifier to the node view holder component and then check that history contains it, and the version of the minimal state is equals to the modifier's identifier.\\

\item \textit{Modifier application should lead to new minimal state whose elements' set intersection with previous ones is not complete.}\\
Whenever a valid modifier is applied, this should lead to a new minimal state taking into account the necessary changes introduced by the transaction inside the modifier. Readers should note that the cardinality of these changes when represented as a set should not be 0, meaning that there should be some changes to the minimal state since the history and the node's view changed on application of the modifier. This implies that the new minimal state should not be completely same as the previous minimal state before the application of the modifier. If they both were same, this would mean that the application of the modifier did not change anything and hence the modifier was empty (not possible). Therefore, with this test we check that the intersection of minimal state before the application of a modifier and after its application is not complete i.e. not all elements in both the minimal states are same.\\
\end{itemize}
\end{enumerate}



%- Valid box should be successfully applied to state, it's available by identifier after that.
%- State should be able to generate changes from valid block and apply them.
%- Wallet should contain secrets for all it's public propositions.
%-
%- Transactions once added to a block should be removed from the local copy of mempool.
%- Minimal state should be able to add and remove boxes based on received transaction's validity.
%-
%- 
%- %- BlockchainSanity test that combines all this test.
