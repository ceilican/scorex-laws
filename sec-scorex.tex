% !TEX root = laws.tex

\section{Scorex Architecture}
\label{sec:scorex}

Scorex is a framework for implementing blockchain clients. A client is a node in a peer-to-peer network. The node has a local view of the network state. The goal of the whole peer-to-peer system\footnote{concretely, its honest nodes. We skip the notion of adversarial behavior for now.} is to synchronize on a critical part of local views. Scorex splits a node's local view into the following four parts: 

\begin{itemize}
\item{\em history} contains log of persistent modifiers. For example, in a Bitcoin-like blockchain the log is about a sequence of blocks. For an arbitrary persistent modifier, a history implementation can define whether the modifier is valid against it or not.
If the modifier is valid w.r.t history, we call it a {\em syntactically} valid modifier. \knote{explain/example}  
\item{\em minimal state} is a structure enough to check semantics of an arbitrary persistent\bruno{persistent has not been defined in the paper yet} modifier with a constraint that the checking has to be deterministic in nature. If a modifier is valid w.r.t minimal state, we call it a {\em semantically} valid modifier.
\item{\em vault} contains user-specific information. A wallet or additional indexes to get richer information from the blockchain are perfect examples of vault implementation. 
\item{\em memory pool} contains temporary objects to be packed into persistent modifiers. An unconfirmed transaction is a clear example of an object living in the pool.
\end{itemize}

The history and the minimal state are parts of local views to be synchronized across the network. For this, nodes run a consensus protocol to form a proper history, and the history should result in a valid minimal state when persistent modifiers contained in history are applied to a prehistorical state.

The whole node view quadruple is to be updated atomically by applying either a persistent node view modifier or an unconfirmed transaction. Scorex provides guarantees of atomicity and consistency for the application while a developer of a concrete system needs to provide implementations for the abstract parts of the quadruple as well as a family of persistent modifiers.

A central component which holds the quadruple {\em <history, minimal state, vault, memory pool>} and processes its updates atomically is called a {\em node view holder}. The holder is implemented as an actor \knote{link}, so that all received messages are processed in sequence, even if received from multiple threads. If the holder gets a transaction, it updates the vault and the memory pool with it. Otherwise, if the holder gets a persistent modifier, it first updates the history by appending the modifier to it. If appending is successful~(i.e. if the modifier is syntactically valid), the modifier is then applied to the minimal state.  \knote{finish, write about forks}

As an example, we consider the cryptocurrency Twinscoin, which has a hybrid Proof-of-Work and Proof-of-Stake consensus protocol. Scorex has a full-fledged Twinscoin implementation as an example of its usage. Underlying Twinscoin, there are two kinds of persistent modifiers: a Proof-of-Work block and a Proof-of-Stake block. 
