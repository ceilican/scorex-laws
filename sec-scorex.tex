% !TEX root = laws.tex

\section{Scorex Architecture}
\label{sec:scorex}

Scorex is a framework for implementing blockchain clients. A client is a node in a peer-to-peer network. The node has a local view of the network state. The goal of the whole peer-to-peer system\footnote{concretely, its honest nodes.} is to synchronize on a critical part of local views. Scorex splits a node's local view into the following four parts: 

\begin{itemize}
\item{\em history} is a log of persistent modifiers. A modifier is persistent in the sense that it has a unique identifier, and it is always possible to check if the modifier was ever appended to the history~(by presenting its identifier). There are no requirements on a modifier structure, besides the requirements to have a unique identifier and at least one parent~(referenced by its identifier). If a modifier could be appended to a history, we call it {\em syntactically} valid. As an example, in a Bitcoin-like blockchain the history is about a chain of blocks. 
If the modifier is valid w.r.t history, we call it a {\em syntactically} valid modifier.  
\item{\em minimal state} is a structure enough to check semantics of an arbitrary persistent modifier with a constraint that the checking has to be deterministic in nature. If a modifier is valid w.r.t minimal state, we call it a {\em semantically} valid modifier.
Thus, in addition to syntax of the blockchain, there is some stateful semantics, and minimal state takes care of them. That is, all nodes agree on some pre-historical state $S_0$ and then by applying the same sequence of persistent modifiers $m_1, \ldots, m_k$ in a deterministic way, all the nodes get the same state $S_k = apply(\ldots apply(apply(S_0, m_1), m_2), m_k)$ if all the $m_1, \ldots, m_k$ are {\em semantically} valid; otherwise a node gets an error on the first application of a semantically invalid persistent modifier. From this mere abstract point of view, the goal of obtaining the state $S_k$ is to check whether a new modifier $m_{k+1}$ will be correct against it or not. Thus the minimal state has very few mandatory functions to implement, such as $apply(\dot)$.
\item{\em vault} contains user-specific information. For a user running a node, the goal to run it is usually to get valuable user-specific information. For that, the vault component is used which has the only function to update itself by scanning a persistent modifier or a {\em transaction}. A transaction, unlike a persistent modifier, has no mandatory reference to its parents; also we consider that a transaction is not to be applied to the history and minimal state. A wallet or additional indexes to get richer information from the blockchain are perfect examples of vault implementation. 
\item{\em memory pool} is storing transactions to be packed into persistent modifiers.
\end{itemize}

The history and the minimal state are parts of local views to be synchronized across the network. For this, nodes run a consensus protocol to form a proper history, and the history should result in a valid minimal state when persistent modifiers contained in history are applied to a publicly known prehistorical state.

The whole node view quadruple is to be updated atomically by applying either a persistent node view modifier or an unconfirmed transaction. Scorex provides guarantees of atomicity and consistency for the application while a developer of a concrete system needs to provide implementations for the abstract parts of the quadruple as well as a family of persistent modifiers.

A central component which holds the quadruple {\em <history, minimal state, vault, memory pool>} and processes its updates atomically is called a {\em node view holder}. The holder is processing all the received messages are processed in sequence, even if they are received from multiple threads. If the holder gets a transaction, it updates the vault and the memory pool with it. Otherwise, if the holder gets a persistent modifier, it first updates the history by appending the modifier to it. If appending is successful~(so if the modifier is syntactically valid), the modifier is then applied to the minimal state.  \knote{finish, write about forks}

As an example, we consider the cryptocurrency Twinscoin~\cite{cryptoeprint:2017:232}, which has a hybrid Proof-of-Work and Proof-of-Stake consensus protocol. Scorex has a full-fledged Twinscoin implementation as an example of its usage. We implement our test suite separately. Then we got working tests for the Twinscoin client just by writing a generators for transactions and persistent modifiers. There are two kinds of persistent modifiers in Twinscoin: a Proof-of-Work block and a Proof-of-Stake block. Thus the blockchain is hybrid: after a Proof-of-Work block it could be only a Proof-of-Stake block, and after the latter it could be only a Proof-of-Work block, again.   
